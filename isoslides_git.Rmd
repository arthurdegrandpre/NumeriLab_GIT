---
title: "NumeriLab - Reproducibility and Collaborative coding"
author: "Arthur de Grandpr√©"
date: "20 mai 2019"
output:
  ioslides_presentation:
    css: styles.css
    logo: images/logo_rive_logo_txt_FR_ENG-01.png
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, include=FALSE, echo=FALSE, warning=FALSE, message=FALSE}
rm(list=ls())
gc()
library(png)
library(grid)
library(knitr)
library(ggplot2)
```

## Context {.build}

Previous workshops have been:  

- Dedicated to enhancing coding and data science level

- Largely based on the R environment  

- Giving strong numeracy bases for everyone attending  
  
But...  
I feel like we still have yet to tackle some of basics of *coding hygiene* like:  

- How to ensure reproducibility of analysis  

- How to ensure safekeeping of your scripts  

- How to collaborate efficiently in your code oriented projects  

## Planning {.build}

The goal of this workshop is that by the end of the hour, attendees are able to figure out their own recipe for efficient collaborative coding.  
  
To do so, we will go through:  

- Basic annotation tips  

- How to structure scripts and projects efficiently  

- How to ensure safekeeping of scripts (version control, backups, etc.)

- How to share your scripts and their results  
  
## Important note

```{r warningsign, echo=FALSE, fig.height=1.5, fig.width=2.5, fig.align='center'}
img1 = readPNG("images/warning.png")
grid.raster(img1)
```
   
There is no single way of doing all that's gonna be shown today.  
  
The following material is based on my personnal experience and what has helped me when working with collaborators.  
  
This is mostly an effort to make sure everyone has some basic reflexes when working on their scripts.  

## Reproducibility

```{r bad annotation, eval=FALSE}

r1=brick("data/test_CIR_clip_01.tif", crs="+init:epsg=26918") ; r1=r1/255
r1$ndvi=(r1$test_CIR_clip_01.1-r1$test_CIR_clip_01.2)/(r1$test_CIR_clip_01.1+r1$test_CIR_clip_01.2)
r2[r2$ndvi<(-0.45) | r2$test_CIR_clip_01.3>0.42]=-10
r3=r2$ndvi
r3[r3>(-10)]=1 ; r3[r3==(-10)]=0
p=rasterToPolygons(r3, dissolve=T)
p=disaggregate(p)
pr=rasterize(p,r3)
ps=PatchStat(pr)
p@data$patchID=rownames(p@data)
p2=merge(p,ps, by="patchID") ; p2=p2[complete.cases(p2@data),]
rc=rasterize(p2, r3, field="ndvi")
pv=p2[p2@data$ndvi==1,]
pr2=rasterize(pv, r3)
PS = PatchStat(pr2)
CS = ClassStat(rc)

```


## Reproducibility (2)
There are many ways to tackle reproducibility of an analysis, the easiest is to think your code for it since $T_0$.  
  
This can be done by: 

- Working by **projects**
- Not procrastinating on the use of # everywhere in your code (don't hesitate to overdescribe, discuss results)  
- Planning your code like you would plan a written document (flowing, logical process)  
- Using R Markdown (Thanks *Lucas*)  
- Structuring your code in the most generic way possible (the less specific you are, the easier it will be to transfer your code)
- Writing your own functions, or even packages  

## Reproducibility (3)

**Bottom line** : Code for future you if not for others

## Reproducibility exemples

(external)

```{r exemple 1, eval=FALSE}

r1=brick("data/test_CIR_clip_01.tif", crs="+init:epsg=26918") ; r1=r1/255
r1$ndvi=(r1$test_CIR_clip_01.1-r1$test_CIR_clip_01.2)/(r1$test_CIR_clip_01.1+r1$test_CIR_clip_01.2)
r2[r2$ndvi<(-0.45) | r2$test_CIR_clip_01.3>0.42]=-10
r3=r2$ndvi
r3[r3>(-10)]=1 ; r3[r3==(-10)]=0
p=rasterToPolygons(r3, dissolve=T)
p=disaggregate(p)
pr=rasterize(p,r3)
ps=PatchStat(pr)
p@data$patchID=rownames(p@data)
p2=merge(p,ps, by="patchID") ; p2=p2[complete.cases(p2@data),]
rc=rasterize(p2, r3, field="ndvi")
pv=p2[p2@data$ndvi==1,]
pr2=rasterize(pv, r3)
PS = PatchStat(pr2)
CS = ClassStat(rc)

```


## Storage and Safekeeping

The most important element of replicability is being able to keep the original work.  
  
There are many different ways to backup your data and scripts.  


It can be done **locally**:  

- using redundancy on multiple devices (backups)  

- can be programmed weekly

- requires different hard drives in different physical locations (some dedication)  

## Storage and Safekeeping (2)

Or **remotely**:  

```{r, echo=FALSE, out.width="40%"}
cloud_logos = list.files("images/logos/", pattern ="*1.png$", full.names = TRUE)
include_graphics(cloud_logos)
```

```{r, echo=FALSE, out.width="25%"}
cloud_logos = list.files("images/logos/", pattern ="*2.png$", full.names = TRUE)
include_graphics(cloud_logos)
```


## Storage and Safekeeping (3)

In most cases, both local and remote backups are necessary.  
- Local is useful for heavier files (very large datasets, high resolution images).  
- Remote allows easier access from different users, or different platforms.  
  
Some parts of the *same project* can be local only, while some others can be hosted remotely.  
  
**So what should be saved where and how?**
